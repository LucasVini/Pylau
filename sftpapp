import os
import sys
import paramiko
import socket
import time
import logging
from PyQt5.QtWidgets import QApplication, QMainWindow, QVBoxLayout, QTextEdit, QPushButton, QWidget
from PyQt5.QtCore import QThread, pyqtSignal, Qt
from PyQt5.QtGui import QTextCharFormat, QFont
import threading

# Fun√ß√£o para obter o IP local da m√°quina
def get_local_ip():
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        s.connect(("8.8.8.8", 80))
        local_ip = s.getsockname()[0]
    except Exception:
        local_ip = "127.0.0.1"
    finally:
        s.close()
    return local_ip

# Diret√≥rio onde os arquivos recebidos ser√£o armazenados
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
RECEIVED_DIR = os.path.join(BASE_DIR, 'SFTP_RECEBIDO')

# Cria o diret√≥rio para os arquivos recebidos se n√£o existir
if not os.path.exists(RECEIVED_DIR):
    os.makedirs(RECEIVED_DIR)

class StubServer(paramiko.ServerInterface):
    def __init__(self, event_handler=None):
        super().__init__()
        self.event_handler = event_handler  # Adicionado para receber o event_handler

    def check_auth_password(self, username, password):
        # Autentica√ß√£o de usu√°rio e senha
        if username == "admin" and password == "@1234567":
            return paramiko.AUTH_SUCCESSFUL
        return paramiko.AUTH_FAILED

    def check_auth_publickey(self, username, key):
        return paramiko.AUTH_FAILED  # Para desativar autentica√ß√£o por chave p√∫blica

    def check_channel_request(self, kind, chanid):
        return paramiko.OPEN_SUCCEEDED

    def get_allowed_auths(self, username):
        return "password"

class StubSFTPHandle(paramiko.SFTPHandle):
    def stat(self):
        try:
            return paramiko.SFTPAttributes.from_stat(os.fstat(self.readfile.fileno()))
        except OSError as e:
            return paramiko.SFTPServer.convert_errno(e.errno)

class StubSFTPServer(paramiko.SFTPServerInterface):
    ROOT = RECEIVED_DIR

    def __init__(self, transport, event_handler):
        super().__init__(transport)
        self.event_handler = event_handler

    def _realpath(self, path):
        return os.path.join(self.ROOT, path.lstrip('/'))

    def list_folder(self, path):
        path = self._realpath(path)
        try:
            out = []
            flist = os.listdir(path)
            for fname in flist:
                attr = paramiko.SFTPAttributes.from_stat(os.stat(os.path.join(path, fname)))
                attr.filename = fname
                out.append(attr)
            return out
        except OSError as e:
            return paramiko.SFTPServer.convert_errno(e.errno)

    def stat(self, path):
        path = self._realpath(path)
        try:
            return paramiko.SFTPAttributes.from_stat(os.stat(path))
        except OSError as e:
            return paramiko.SFTPServer.convert_errno(e.errno)

    def lstat(self, path):
        path = self._realpath(path)
        try:
            return paramiko.SFTPAttributes.from_stat(os.lstat(path))
        except OSError as e:
            return paramiko.SFTPServer.convert_errno(e.errno)

    def open(self, path, flags, attr):
        path = self._realpath(path)
        try:
            binary_flag = getattr(os, 'O_BINARY', 0)
            flags |= binary_flag
            mode = getattr(attr, 'st_mode', None)
            if mode is not None:
                fd = os.open(path, flags, mode)
            else:
                fd = os.open(path, flags, 0o666)
        except OSError as e:
            return paramiko.SFTPServer.convert_errno(e.errno)
        if (flags & os.O_CREAT) and (attr is not None):
            attr._flags &= ~attr.FLAG_PERMISSIONS
            paramiko.SFTPServer.set_file_attr(path, attr)
        if flags & os.O_WRONLY:
            if flags & os.O_APPEND:
                fstr = 'ab'
            else:
                fstr = 'wb'
        elif flags & os.O_RDWR:
            if flags & os.O_APPEND:
                fstr = 'a+b'
            else:
                fstr = 'r+b'
        else:
            fstr = 'rb'
        try:
            f = os.fdopen(fd, fstr)
        except OSError as e:
            return paramiko.SFTPServer.convert_errno(e.errno)
        fobj = StubSFTPHandle(flags)
        fobj.filename = path
        fobj.readfile = f
        fobj.writefile = f

        # Log de arquivo aberto/criado
        if flags & os.O_CREAT:
            self.event_handler.log_signal.emit(f"Arquivo criado: {path}")
        elif flags & os.O_RDWR:
            self.event_handler.log_signal.emit(f"Arquivo aberto para leitura/escrita: {path}")
        elif flags & os.O_WRONLY:
            self.event_handler.log_signal.emit(f"Arquivo aberto para escrita: {path}")
        else:
            self.event_handler.log_signal.emit(f"Arquivo aberto para leitura: {path}")

        return fobj

    def remove(self, path):
        path = self._realpath(path)
        try:
            os.remove(path)
            self.event_handler.log_signal.emit(f"Arquivo removido: {path}")
        except OSError as e:
            return paramiko.SFTPServer.convert_errno(e.errno)
        return paramiko.SFTP_OK

    def rename(self, oldpath, newpath):
        oldpath = self._realpath(oldpath)
        newpath = self._realpath(newpath)
        try:
            os.rename(oldpath, newpath)
            self.event_handler.log_signal.emit(f"Arquivo renomeado de {oldpath} para {newpath}")
        except OSError as e:
            return paramiko.SFTPServer.convert_errno(e.errno)
        return paramiko.SFTP_OK

    def mkdir(self, path, attr):
        path = self._realpath(path)
        try:
            os.mkdir(path)
            if attr is not None:
                paramiko.SFTPServer.set_file_attr(path, attr)
            self.event_handler.log_signal.emit(f"Diret√≥rio criado: {path}")
        except OSError as e:
            return paramiko.SFTPServer.convert_errno(e.errno)
        return paramiko.SFTP_OK

    def rmdir(self, path):
        path = self._realpath(path)
        try:
            os.rmdir(path)
            self.event_handler.log_signal.emit(f"Diret√≥rio removido: {path}")
        except OSError as e:
            return paramiko.SFTPServer.convert_errno(e.errno)
        return paramiko.SFTP_OK

    def chattr(self, path, attr):
        path = self._realpath(path)
        try:
            paramiko.SFTPServer.set_file_attr(path, attr)
        except OSError as e:
            return paramiko.SFTPServer.convert_errno(e.errno)
        return paramiko.SFTP_OK

    def symlink(self, target_path, path):
        path = self._realpath(path)
        if (len(target_path) > 0) and (target_path[0] == '/'):
            target_path = os.path.join(self.ROOT, target_path[1:])
        else:
            abspath = os.path.join(os.path.dirname(path), target_path)
            if abspath[:len(self.ROOT)] != self.ROOT:
                target_path = '<error>'
        try:
            os.symlink(target_path, path)
        except OSError as e:
            return paramiko.SFTPServer.convert_errno(e.errno)
        return paramiko.SFTP_OK

    def readlink(self, path):
        path = self._realpath(path)
        try:
            symlink = os.readlink(path)
        except OSError as e:
            return paramiko.SFTPServer.convert_errno(e.errno)
        if os.path.isabs(symlink):
            if symlink[:len(self.ROOT)] == self.ROOT:
                symlink = symlink[len(self.ROOT):]
                if (len(symlink) == 0) or (symlink[0] != '/'):
                    symlink = '/' + symlink
            else:
                symlink = '<error>'
        return symlink

class SFTPServerThread(QThread):
    log_signal = pyqtSignal(str)

    def __init__(self, host, port, keyfile, level):
        super().__init__()
        self.host = host
        self.port = port
        self.keyfile = keyfile
        self.level = level
        self.running = True
        self.server_socket = None
        self.stop_event = threading.Event()
        self.active_transports = []  # Lista para manter as conex√µes ativas

    def run(self):
        logging.basicConfig(level=getattr(logging, self.level.upper(), logging.INFO))

        local_ip = get_local_ip()
        self.log_signal.emit(f"Servidor SFTP iniciado em {local_ip}:{self.port}")

        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
        self.server_socket.bind((self.host, self.port))
        self.server_socket.listen(10)
        self.server_socket.settimeout(1.0)

        while self.running and not self.stop_event.is_set():
            try:
                conn, addr = self.server_socket.accept()
                conn.settimeout(None)

                host_key = paramiko.RSAKey.generate(2048)
                self.log_signal.emit(f"Chave RSA gerada: {host_key.get_base64()}")

                transport = paramiko.Transport(conn)
                transport.add_server_key(host_key)
                server = StubServer(event_handler=self)
                transport.set_subsystem_handler('sftp', paramiko.SFTPServer, StubSFTPServer, event_handler=self)

                try:
                    transport.start_server(server=server)
                except paramiko.SSHException as e:
                    self.log_signal.emit(f"Erro de autentica√ß√£o: {e}")
                    continue

                channel = transport.accept()
                if channel is None:
                    self.log_signal.emit("Falha na autentica√ß√£o.")
                else:
                    self.log_signal.emit(f"Cliente conectado: {addr}")
                    self.active_transports.append(transport)  # Adiciona o transporte √† lista

                while transport.is_active() and self.running and not self.stop_event.is_set():
                    time.sleep(0.5)

            except socket.timeout:
                continue
            except Exception as e:
                if self.running:
                    self.log_signal.emit(f"Erro no servidor: {e}")
                break

        # Fechar todas as conex√µes ativas
        for transport in self.active_transports:
            if transport.is_active():
                transport.close()
        self.active_transports.clear()

        self.server_socket.close()
        self.log_signal.emit("Servidor SFTP parado.")


    def stop(self):
        self.running = False
        self.stop_event.set()  # Sinaliza o evento de parada

        # Fechar todas as conex√µes ativas
        for transport in self.active_transports:
            if transport.is_active():
                transport.close()
        self.active_transports.clear()

        if self.server_socket:
            self.server_socket.close()
        self.wait()

class SFTPApplication(QApplication):
    log_signal = pyqtSignal(str)

    def __init__(self, argv):
        super().__init__(argv)
        self.init_ui()
        self.server_thread = None

    def init_ui(self):
        self.main_window = QMainWindow()
        self.main_window.setWindowTitle("Servidor SFTP")
        self.main_window.resize(500, 400)

        # Centralizar a janela
        screen = QApplication.desktop().screenGeometry()
        size = self.main_window.geometry()
        self.main_window.move(
            int((screen.width() - size.width()) / 2),
            int((screen.height() - size.height()) / 2)
        )

        # Cor de fundo verde escuro
        self.main_window.setStyleSheet("background-color: #004000;")

        central_widget = QWidget()
        self.main_window.setCentralWidget(central_widget)

        layout = QVBoxLayout(central_widget)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(10)

        # Console de log com fonte branca e fundo transparente
        self.log_console = QTextEdit()
        self.log_console.setReadOnly(True)
        self.log_console.setStyleSheet("""
            background-color: rgba(0, 0, 0, 50); /* Fundo preto transparente */
            color: #DCDCDC; /* Cinza claro para melhor contraste */
            font-family: 'Arial', sans-serif; /* Fonte alterada para Arial */
            font-size: 10pt;
            border: 1px solid #008000; /* Borda verde claro */
            border-radius: 5px;
            padding: 5px;
            selection-background-color: #71ff78; /* Verde claro ao selecionar */
            selection-color: black;
        """)
        layout.addWidget(self.log_console)

        # Bot√µes com estilo
        self.start_button = QPushButton("üîê Iniciar Servidor")
        self.stop_button = QPushButton("‚õî Parar Servidor")
        self.stop_button.setEnabled(False)

        button_style = """
            QPushButton {
                background-color: #006400; /* Verde mais escuro */
                color: white;
                font-family: 'Arial', sans-serif;
                font-size: 12pt;
                font-weight: bold;
                border: none;
                border-radius: 5px;
                padding: 10px;
            }
            QPushButton:hover {
                background-color: #008000; /* Verde claro no hover */
            }
            QPushButton:pressed {
                background-color: #00A000; /* Verde mais claro no clique */
            }
            QPushButton:disabled {
                background-color: #A9A9A9; /* Cinza desabilitado */
                color: #696969;
            }
        """
        self.start_button.setStyleSheet(button_style)
        self.stop_button.setStyleSheet(button_style)

        layout.addWidget(self.start_button)
        layout.addWidget(self.stop_button)

        self.start_button.clicked.connect(self.start_server)
        self.stop_button.clicked.connect(self.stop_server)
    
    def log_message(self, message):
        self.log_console.append(message)

    def start_server(self):
        host = "0.0.0.0"
        port = 2222
        keyfile = None
        level = "INFO"


        self.server_thread = SFTPServerThread(host, port, keyfile, level)
        self.server_thread.log_signal.connect(self.log_message)
        self.server_thread.start()

        self.start_button.setEnabled(False)
        self.stop_button.setEnabled(True)

    def stop_server(self):
        if self.server_thread:
            self.server_thread.stop()
            self.server_thread.wait()

        self.start_button.setEnabled(True)
        self.stop_button.setEnabled(False)
        self.log_message("Voc√™ pode fechar essa janela ou iniciar novamente.")

    def log_message(self, message):
        # Palavras-chave para destacar
        keywords = ["Conectado", "Desconectado", "Chave RSA gerada", "Arquivo criado", "Arquivo aberto", "Arquivo removido", "Arquivo renomeado", "Diret√≥rio criado", "Diret√≥rio removido", "Erro", "Falha", "iniciado", "parado"]

        # Formata√ß√£o para palavras-chave
        keyword_format = QTextCharFormat()
        keyword_format.setFontWeight(QFont.Bold)
        keyword_format.setForeground(Qt.yellow)  # Amarelo para destacar

        # Formata√ß√£o para outros destaques (ex: nomes de arquivos)
        highlight_format = QTextCharFormat()
        highlight_format.setForeground(Qt.green) # Azul claro

        self.log_console.moveCursor(self.log_console.textCursor().End) # Mover o cursor para o final

        parts = message.split(":")
        if len(parts) > 1:
            prefix = parts[0].strip()
            if prefix in keywords:
                self.log_console.setCurrentCharFormat(keyword_format)
                self.log_console.insertPlainText(prefix + ":")
                self.log_console.setCurrentCharFormat(QTextCharFormat()) # Resetar a formata√ß√£o

                # Tratar o restante da mensagem
                remainder = ":".join(parts[1:]).strip()
                if prefix == "Chave RSA gerada":
                    self.log_console.insertPlainText(" " + remainder + "\n")
                elif prefix in ["Arquivo criado", "Arquivo aberto", "Arquivo removido", "Arquivo renomeado", "Diret√≥rio criado", "Diret√≥rio removido"]:
                    self.log_console.setCurrentCharFormat(highlight_format)
                    self.log_console.insertPlainText(" " + remainder + "\n")
                else:
                    self.log_console.insertPlainText(" " + remainder + "\n")
            else:
                self.log_console.append(message)
        else:
            self.log_console.append(message)
    def show_window(self):
        self.main_window.show()

def main():
    app = SFTPApplication(sys.argv)
    app.show_window()
    sys.exit(app.exec_())

if __name__ == '__main__':
    main()
