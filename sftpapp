import os
import sys
import paramiko
import socket
import time
import logging
from PyQt5.QtWidgets import QApplication, QMainWindow, QVBoxLayout, QTextEdit, QPushButton, QWidget
from PyQt5.QtCore import QThread, pyqtSignal

# Função para obter o IP local da máquina
def get_local_ip():
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        s.connect(("8.8.8.8", 80))
        local_ip = s.getsockname()[0]
    except Exception:
        local_ip = "127.0.0.1"
    finally:
        s.close()
    return local_ip

# Diretório onde os arquivos recebidos serão armazenados
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
RECEIVED_DIR = os.path.join(BASE_DIR, 'SFTP_RECEBIDO')

# Cria o diretório para os arquivos recebidos se não existir
if not os.path.exists(RECEIVED_DIR):
    os.makedirs(RECEIVED_DIR)

class StubServer(paramiko.ServerInterface):
    def check_auth_password(self, username, password):
        # Autenticação de usuário e senha
        if username == "admin" and password == "@1234567":
            return paramiko.AUTH_SUCCESSFUL
        return paramiko.AUTH_FAILED

    def check_auth_publickey(self, username, key):
        return paramiko.AUTH_FAILED  # Para desativar autenticação por chave pública

    def check_channel_request(self, kind, chanid):
        return paramiko.OPEN_SUCCEEDED

    def get_allowed_auths(self, username):
        return "password"

class StubSFTPHandle(paramiko.SFTPHandle):
    def stat(self):
        try:
            return paramiko.SFTPAttributes.from_stat(os.fstat(self.readfile.fileno()))
        except OSError as e:
            return paramiko.SFTPServer.convert_errno(e.errno)

class StubSFTPServer(paramiko.SFTPServerInterface):
    ROOT = RECEIVED_DIR

    def _realpath(self, path):
        return os.path.join(self.ROOT, path.lstrip('/'))

    def list_folder(self, path):
        path = self._realpath(path)
        try:
            out = []
            flist = os.listdir(path)
            for fname in flist:
                attr = paramiko.SFTPAttributes.from_stat(os.stat(os.path.join(path, fname)))
                attr.filename = fname
                out.append(attr)
            return out
        except OSError as e:
            return paramiko.SFTPServer.convert_errno(e.errno)

    def stat(self, path):
        path = self._realpath(path)
        try:
            return paramiko.SFTPAttributes.from_stat(os.stat(path))
        except OSError as e:
            return paramiko.SFTPServer.convert_errno(e.errno)

    def lstat(self, path):
        path = self._realpath(path)
        try:
            return paramiko.SFTPAttributes.from_stat(os.lstat(path))
        except OSError as e:
            return paramiko.SFTPServer.convert_errno(e.errno)

    def open(self, path, flags, attr):
        path = self._realpath(path)
        try:
            binary_flag = getattr(os, 'O_BINARY', 0)
            flags |= binary_flag
            mode = getattr(attr, 'st_mode', None)
            if mode is not None:
                fd = os.open(path, flags, mode)
            else:
                fd = os.open(path, flags, 0o666)
        except OSError as e:
            return paramiko.SFTPServer.convert_errno(e.errno)
        if (flags & os.O_CREAT) and (attr is not None):
            attr._flags &= ~attr.FLAG_PERMISSIONS
            paramiko.SFTPServer.set_file_attr(path, attr)
        if flags & os.O_WRONLY:
            if flags & os.O_APPEND:
                fstr = 'ab'
            else:
                fstr = 'wb'
        elif flags & os.O_RDWR:
            if flags & os.O_APPEND:
                fstr = 'a+b'
            else:
                fstr = 'r+b'
        else:
            fstr = 'rb'
        try:
            f = os.fdopen(fd, fstr)
        except OSError as e:
            return paramiko.SFTPServer.convert_errno(e.errno)
        fobj = StubSFTPHandle(flags)
        fobj.filename = path
        fobj.readfile = f
        fobj.writefile = f
        return fobj

    def remove(self, path):
        path = self._realpath(path)
        try:
            os.remove(path)
        except OSError as e:
            return paramiko.SFTPServer.convert_errno(e.errno)
        return paramiko.SFTP_OK

    def rename(self, oldpath, newpath):
        oldpath = self._realpath(oldpath)
        newpath = self._realpath(newpath)
        try:
            os.rename(oldpath, newpath)
        except OSError as e:
            return paramiko.SFTPServer.convert_errno(e.errno)
        return paramiko.SFTP_OK

    def mkdir(self, path, attr):
        path = self._realpath(path)
        try:
            os.mkdir(path)
            if attr is not None:
                paramiko.SFTPServer.set_file_attr(path, attr)
        except OSError as e:
            return paramiko.SFTPServer.convert_errno(e.errno)
        return paramiko.SFTP_OK

    def rmdir(self, path):
        path = self._realpath(path)
        try:
            os.rmdir(path)
        except OSError as e:
            return paramiko.SFTPServer.convert_errno(e.errno)
        return paramiko.SFTP_OK

    def chattr(self, path, attr):
        path = self._realpath(path)
        try:
            paramiko.SFTPServer.set_file_attr(path, attr)
        except OSError as e:
            return paramiko.SFTPServer.convert_errno(e.errno)
        return paramiko.SFTP_OK

    def symlink(self, target_path, path):
        path = self._realpath(path)
        if (len(target_path) > 0) and (target_path[0] == '/'):
            target_path = os.path.join(self.ROOT, target_path[1:])
        else:
            abspath = os.path.join(os.path.dirname(path), target_path)
            if abspath[:len(self.ROOT)] != self.ROOT:
                target_path = '<error>'
        try:
            os.symlink(target_path, path)
        except OSError as e:
            return paramiko.SFTPServer.convert_errno(e.errno)
        return paramiko.SFTP_OK

    def readlink(self, path):
        path = self._realpath(path)
        try:
            symlink = os.readlink(path)
        except OSError as e:
            return paramiko.SFTPServer.convert_errno(e.errno)
        if os.path.isabs(symlink):
            if symlink[:len(self.ROOT)] == self.ROOT:
                symlink = symlink[len(self.ROOT):]
                if (len(symlink) == 0) or (symlink[0] != '/'):
                    symlink = '/' + symlink
            else:
                symlink = '<error>'
        return symlink

class SFTPServerThread(QThread):
    log_signal = pyqtSignal(str)

    def __init__(self, host, port, keyfile, level):
        super().__init__()
        self.host = host
        self.port = port
        self.keyfile = keyfile
        self.level = level
        self.running = True

    def run(self):
        logging.basicConfig(level=getattr(logging, self.level.upper(), logging.INFO))

        local_ip = get_local_ip()
        self.log_signal.emit(f"Servidor SFTP iniciado em {local_ip}:{self.port}")

        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
        server_socket.bind((self.host, self.port))
        server_socket.listen(10)
        server_socket.settimeout(1.0)  # Adicionado timeout para evitar bloqueio

        while self.running:
            try:
                conn, addr = server_socket.accept()
            except socket.timeout:
                continue  # Permite que o loop continue sem travar
            except Exception as e:
                self.log_signal.emit(f"Erro no servidor: {e}")
                break

            host_key = paramiko.RSAKey.generate(2048)
            transport = paramiko.Transport(conn)
            transport.add_server_key(host_key)
            transport.set_subsystem_handler('sftp', paramiko.SFTPServer, StubSFTPServer)

            server = StubServer()
            try:
                transport.start_server(server=server)
            except paramiko.SSHException as e:
                self.log_signal.emit(f"Erro de autenticação: {e}")
                continue

            channel = transport.accept()
            if channel is None:
                self.log_signal.emit("Falha na autenticação.")
            else:
                self.log_signal.emit(f"Cliente conectado: {addr}")

            while transport.is_active() and self.running:
                time.sleep(0.5)  # Reduzido para evitar consumo excessivo de CPU

        server_socket.close()
        self.log_signal.emit("Servidor SFTP parado.")

    def stop(self):
        self.running = False
        self.wait(1000)  # Espera um pouco antes de forçar a parada


    def stop(self):
        self.running = False
        self.quit()

# Aplicação PyQt5 para ser incorporada
class SFTPApplication(QApplication):
    log_signal = pyqtSignal(str)

    def __init__(self, argv):
        super().__init__(argv)
        self.init_ui()
        self.server_thread = None

    def init_ui(self):
        self.main_window = QMainWindow()
        self.main_window.setWindowTitle("Servidor SFTP")
        self.main_window.resize(500, 400)  # Aumentei o tamanho para melhor visualização

        # Centralizar a janela
        screen = QApplication.desktop().screenGeometry()
        size = self.main_window.geometry()
        self.main_window.move(
            int((screen.width() - size.width()) / 2),
            int((screen.height() - size.height()) / 2)
        )

        # Cor de fundo verde escuro
        self.main_window.setStyleSheet("background-color: #004000;")  # Verde escuro

        central_widget = QWidget()
        self.main_window.setCentralWidget(central_widget)

        layout = QVBoxLayout(central_widget)
        layout.setContentsMargins(10, 10, 10, 10) # Adiciona margens
        layout.setSpacing(10)  # Adiciona espaçamento

        # Console de log com fonte branca e fundo transparente
        self.log_console = QTextEdit()
        self.log_console.setReadOnly(True)
        self.log_console.setStyleSheet("""
            background-color: rgba(0, 0, 0, 50); /* Fundo preto transparente */
            color: white;
            font-family: 'Courier New', monospace;
            font-size: 11pt;
            border: 1px solid #008000; /* Borda verde claro */
            border-radius: 5px;
            padding: 5px;
            selection-background-color: #71ff78; /* Verde claro ao selecionar */
            selection-color: black;
        """)
        layout.addWidget(self.log_console)

        # Botões com estilo
        self.start_button = QPushButton("🔐 Iniciar Servidor")
        self.stop_button = QPushButton("⛔ Parar Servidor")
        self.stop_button.setEnabled(False)

        button_style = """
            QPushButton {
                background-color: #006400; /* Verde mais escuro */
                color: white;
                font-family: 'Arial', sans-serif;
                font-size: 12pt;
                font-weight: bold;
                border: none;
                border-radius: 5px;
                padding: 10px;
            }
            QPushButton:hover {
                background-color: #008000; /* Verde claro no hover */
            }
            QPushButton:pressed {
                background-color: #00A000; /* Verde mais claro no clique */
            }
            QPushButton:disabled {
                background-color: #A9A9A9; /* Cinza desabilitado */
                color: #696969;
            }
        """
        self.start_button.setStyleSheet(button_style)
        self.stop_button.setStyleSheet(button_style)

        layout.addWidget(self.start_button)
        layout.addWidget(self.stop_button)

        self.start_button.clicked.connect(self.start_server)
        self.stop_button.clicked.connect(self.stop_server)

    def log_message(self, message):
        self.log_console.append(message)

    def start_server(self):
        host = "0.0.0.0"
        port = 2222
        keyfile = None
        level = "INFO"

        self.server_thread = SFTPServerThread(host, port, keyfile, level)
        self.server_thread.log_signal.connect(self.log_message)
        self.server_thread.start()

        self.start_button.setEnabled(False)
        self.stop_button.setEnabled(True)

    def stop_server(self):
        if self.server_thread:
            self.server_thread.stop()
            self.server_thread.wait()

        self.start_button.setEnabled(True)
        self.stop_button.setEnabled(False)
        self.log_message("Você pode fechar essa janela ou iniciar novamente.")

    def show_window(self):
        self.main_window.show()

def main():
    app = SFTPApplication(sys.argv)
    app.show_window()
    sys.exit(app.exec_())

if __name__ == '__main__':
    main()
